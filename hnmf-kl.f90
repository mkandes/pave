! ======================================================================
! hnmf-kl-matmul
! Algorithms for Nonnegative Matrix Factorizationwith the 
! Kullback-Leibler Divergence
! https://arxiv.org/pdf/2010.01935.pdf
! TODO: adjust for non-square matrix case; mxn = mxk * kxn
! ----------------------------------------------------------------------
      program hnmf

!     load standard iso_fortran_env module
      use, intrinsic :: iso_fortran_env

!     disable implicit variable types
      implicit none

!     declare character-valued input buffer variable that will be 
!     utilized to read in matrix and vector dimension n from command-line;
!     20 characters is the max length of a signed 64-bit integer
      character(20) :: buffer

!     declare integer-valued variables that will be utilized to store:
!     length and info variables for get_command_argument subroutine; 
!     loop indicies i, j; matrix dimension n; size of the random seed 
!     array; and IO status code
      integer :: length, info
      integer :: i, j, n
      integer :: seed_size = 42
      integer :: io_status

!     declare a one-dimensional integer-valued array that will be used 
!     to store the random seed that initializes the pseudo-random number 
!     sequence generated by the RANDOM_NUMBER intrinsic procedure.
      integer, allocatable, dimension(:) :: seed

!     declare two-dimensional real-valued arrays that will be utilized 
!     to store the matrices V, W, and H as well as a ONES matrix

      real, allocatable, dimension(:,:) :: V, W, H, ONES

!     read in the matrix and vector dimension n from command-line
      call get_command_argument(1, buffer, length, info)
      read(unit=buffer, fmt=*) n

!     allocate memory for the one-dimensional array used to store
!     the random seed 
      allocate(seed(seed_size))

!     allocate memory for the two-dimensional arrays used to store 
!     the matrices V, W, and H
      allocate(V(n,n))
      allocate(W(n,n))
      allocate(H(n,n))
      allocate(ONES(n,n))

!     initialize the random seed by reading output from /dev/urandom
!     https://gcc.gnu.org/onlinedocs/gcc-4.7.4/gfortran/RANDOM_005fSEED.html
      call random_seed(size=seed_size)
      open(unit=42, file='/dev/urandom', access='stream', &
         & form='unformatted', action='read', status='old', &
         & iostat=io_status)
      if (io_status == 0) then
         read(unit=42,iostat=io_status) seed
      end if
      close(unit=42)
      call random_seed(put=seed)

!     initialize the two-dimensional array V as the Hilbert matrix of
!     dimension n
      do j = 1, n 
         do i = 1, n
            V(i,j) =  1.0 / float(i+j-1)
         end do
      end do

!     initialize the elements of the two-dimensional arrays W and H with
!     uniformly distributed random numbers on the unit interval [0,1). 
      call random_number(W)
      call random_number(H)

!     initialize the all-ones matrix
      ONES = 1.0

!     write V and the initial W and H matrices to a file.
      open(unit=999, file='v.exact', access='sequential', &
         & form='formatted', action='write', status='new', &
         & iostat=io_status)
      if (io_status == 0) then
         do j = 1, n
            do i = 1, n
               write(unit=999,fmt='(F23.15)',iostat=io_status) V(i,j)
            end do
         end do
      end if
      close(unit=999)

      open(unit=1000, file='w.initial', access='sequential', &
         & form='formatted', action='write', status='new', &
         & iostat=io_status)
      if (io_status == 0) then
         do j = 1, n
            do i = 1, n
               write(unit=1000,fmt='(F23.15)',iostat=io_status) W(i,j)
            end do
         end do
      end if
      close(unit=1000)

      open(unit=1001, file='h.initial', access='sequential', &
         & form='formatted', action='write', status='new', &
         & iostat=io_status)
      if (io_status == 0) then
         do j = 1, n
            do i = 1, n
               write(unit=1001,fmt='(F23.15)',iostat=io_status) H(i,j)
            end do
         end do
      end if
      close(unit=1001)

!     perform non-negative matrix factorization via the multiplicative 
!     update rule that minimizes the Kullback-Leibler divergence
      do i = 1, 1000000
         H=H*(MATMUL(TRANSPOSE(W),V/MATMUL(W,H))/MATMUL(TRANSPOSE(W),ONES))
         W=W*(MATMUL(V/MATMUL(W,H),TRANSPOSE(H))/MATMUL(ONES,TRANSPOSE(H)))
      end do

!     compute the approximation of V from W and H
      V = MATMUL(W,H)

!     write the approximation of V and the final W and H matrices to a file
      open(unit=999, file='v.approx', access='sequential', &
         & form='formatted', action='write', status='new', &
         & iostat=io_status)
      if (io_status == 0) then
         do j = 1, n
            do i = 1, n
               write(unit=999,fmt='(F23.15)',iostat=io_status) V(i,j)
            end do
         end do
      end if
      close(unit=999)

      open(unit=1000, file='w.final', access='sequential', &
         & form='formatted', action='write', status='new', &
         & iostat=io_status)
      if (io_status == 0) then
         do j = 1, n
            do i = 1, n
               write(unit=1000,fmt='(F23.15)',iostat=io_status) W(i,j)
            end do
         end do
      end if
      close(unit=1000)

      open(unit=1001, file='h.final', access='sequential', &
         & form='formatted', action='write', status='new', &
         & iostat=io_status)
      if (io_status == 0) then
         do j = 1, n
            do i = 1, n
               write(unit=1001,fmt='(F23.15)',iostat=io_status) H(i,j)
            end do
         end do
      end if
      close(unit=1001)

!     deallocate memory utilized for the one- and two-dimensional arrays 
!     used to store the random seed and matrices V, W, and H.
      deallocate(seed)
      deallocate(V)
      deallocate(W)
      deallocate(H)

      stop

      end program hnmf
! ======================================================================
